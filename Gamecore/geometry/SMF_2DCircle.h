#ifndef __SMF_CIRCLE_2D_
#define __SMF_CIRCLE_2D_

#include "../SMF_Config.h"
#include "../math/all.h"
#include "SMF_2DConics.h"
#include "all.h"

namespace SMF {
using namespace MATH;
using namespace Util;
namespace GEO{




 /**
 * \class CCircle2D
 *
 * \ingroup SMF_Geometric
 * \image html pics/circle.png
 * \if pt_br
 * \brief Um Círculo em duas dimensões num espaço cartesiano
 * \note Esta classe representa tanto um disco (círculo sólido), quanto um anel (somente a borda)
 * \note \n formula:  \f$ R^2 = (x - a)^2 + (y - b)^2  \f$
		 \n onde:  
		 \n R = raio
		 \n	C (a,b) = ponto central
 * \elseif us_en
 * \brief A two-dimensional circle in 2D space.
 * \note This class represents both a hollow circle (only edge) and a solid circle (disc).
 *       formula: 
 *		 \n \f$ R^2 = (x - a)^2 + (y - b)^2  \f$
		 \n where:  
		 \n R = radius
		 \n	C (a,b) = central point 
 *
 * \endif
 *
 * \author (last to touch it) $Autor: Rasputtim $
 *
 * \version 1.0 $Revision: 1.0 $
 *
 * Contact: Rasputtim@hotmail.com
 *
 */
class SMF_API CCircle2D: public CConic2D
{
public:

	/// The center position of this circle.
	CPoint2D center;
 
	/** 
	\brief The radius of the circle. [similarOverload: center]
	 This parameter must be strictly positive to specify a non-degenerate circle. If zero is specified, this circle
		is considered to be degenerate.
	\see CCircle2D::CCircle2D(). */
	float r;

	/** 
	\brief  The default constructor does not initialize any members of this class.
	 This means that the values of the members center, normal and r are all undefined after creating a new circle using
		this default constructor. Remember to assign to them before use.
	\see center, normal, r. */
	CCircle2D();

	/** 
	\brief  Constructs a new circle by explicitly specifying the member variables.
	\param center The center point of the circle.
	\param radius The radius of the circle.
	\see center, normal, r. */
	CCircle2D(CPoint2D center,  float radius);
	/** 
	\brief  Constructs a new circle by explicitly 3 points.
	\param p1 one point on the circle edge.
	\param p2 one point on the circle edge.
	\param p3 one point on the circle edge
	\see center, normal, r. */
	CCircle2D(CPoint2D p1,  CPoint2D p2,CPoint2D p3);
	/** 
	\brief  Constructs a new circle by explicitly 2 points and the radius.
	\param p1 one point on the circle edge.
	\param p2 one point on the circle edge.
	\param radius the radius of the circle.
	\param orientation case there are two possible cicles, choose the orientation of the built one. orientation [RightHandSide,LeftHandSide1]
	\note if it is not possible to build a circle from the points and radius passed, ill return a degenerate one,
	with center at a infinite point and radius =0;
	\see center, normal, r. */
	CCircle2D::CCircle2D(CPoint2D p1, CPoint2D p2, float radius, int orientation=RightHandSide);
	
	/** 
	\if pt_br
	\brief Testa se o circulo é \b finito \b
	\note A esfera é \b finito \b se seus membros origin e radius não possuem NaNs (not a number http://en.wikipedia.org/wiki/NaN) ou números infinitos +/-. \n
	\elseif us_en
	\brief Tests if this Circle is finite.
	\note A circle is \b finite \b if its members origin and radius do not contain floating-point NaNs or +/-infs
		in them.
	\return True if the members pos and r both have finite floating-point values.
	\endif
	\see origin, radius, isDegenerate(), isFinite(), isInf(), IsNan(), isFinite(), CMath::INFINITE_FLOAT, CMath::NEG_INFINITE_FLOAT, CMath::NAN_FLOAT, CVec3D::nan, CVec3D::infinity. */
	bool isFinite() const;
	/** 
	\if pt_br
	\brief Retorna verdaddeiro se o circulo é \b degenerado \b.
	\note Um esfera é degenerada se ela não for finita, ou se seu raio for menor ou igual a zero \n
	\elseif us_en
	\brief Returns true if this Circle is \b degenerate \b.
	\note A Circle is \b degenerate \b if it is not finite, or if the radius of the circle is less or equal to 0. \p
	\endif
	\see origin, radius, isFinite() 
	**/
	bool isDegenerate() const;
	
	///circle eccentricity =0;
	float getEccentricity()const{return 0;};

	/** 
	\brief return a coeficient from circle formula (x-a)2 + (y-b)2=r2
	  onde C(a,b) é o centro do circulo*/
	float a(){ return center.x_;};

	///return a coeficient from circle formula
	float b(){return center.y_;};

	float getRadius()const {return r;}
	float radius()const {return r;}

	void set(CPoint2D &center, float radius);

	/** Get curve sagitta at specified distance from origin.
         \param dist distance from circle origin */
    float sagitta(float dist) const;
	/** 
	\brief  Returns a point at the edge of this circle.
	\param angleRadians The direction of the point to get. A full circle is generated by the range [0, 2*pi],
			but it is ok to pass in values outside this range.
	\note This function is equivalent to calling getPoint(float angleRadians, float d) with a value of d == 1.
	\return A point in world space at the edge of this circle. */
	virtual CPoint2D getPoint(float angleRadians) const;

	/** 
	\brief  Returns a point inside this circle.
	\param angleRadians The direction of the point to get. A full circle is generated by the range [0, 2*pi],
			but it is ok to pass in values outside this range.
	\param d A value in the range [0,1] that specifies the normalzied distance of the point from the center of the circle.
			A value of 0 returns the center point of this circle. A value of 1 returns a point at the edge of this circle.
			The range of d is not restricted, so it is ok to pass in values larger than 1 to generate a point lying completely
			outside this circle. */
	virtual CPoint2D getPoint(float angleRadians, float d) const;

	/** 
	\brief  Returns the center point of this circle.
	 This point is also the center of mass for this circle. The functions centerPoint() and centroid() are equivalent.
	\see center. */
	CPoint2D centerPoint() const { return center; }
	CPoint2D centroid() const { return center; } ///< [similarOverload: centerPoint]
	CPoint2D getOrigin() const { return center; }
	CPoint2D origin() const { return center; }

	/** 
	\brief  Translates this CCircle2D in world space.
	\param offset The amount of displacement to apply to this CCircle2D, in world space coordinates.
	\see transform(). */
	void translate(const CVec2D &offset);

	/** 
	\brief  Applies a transformation to this CCircle2D.
	\param transform The transformation to apply to this CCircle2D. This transformation must be
		affine, and must contain an orthogonal set of column vectors (may not contain shear or projection).
		The transformation can only contain uniform scale, and may not contain mirroring.
	\see translate(), scale(), classes CMat3D, CMatJoint3x4, CMat4D, CQuaternion. */
	void transform(const CMat2D &transform);

	/** 
	\brief  Tests if the given point is contained at the edge of this circle.
	\param point The target point to test.
	\param maxDistance The epsilon threshold to test the distance against. This effectively turns the circle into a torus
			for this test.
	\see distanceToEdge(), distanceToDisc(), closestPointToEdge(), closestPointToDisc().
	\todo Implement DiscContains(CVec2D/CLineSegment/CTriangle). */
	virtual bool edgeContains(const CPoint2D &point, float maxDistance = 1e-6f) const;

	// Returns true if the given point lies inside this filled circle.
	// \param maxDistance The epsilon threshold to test the distance against.
//	bool DiscContains(const CVec2D &point, float maxDistance = 1e-6f) const;
//	bool DiscContains(const CLineSegment &lineSegment, float maxDistance = 1e-6f) const;

	/** 
	\brief  Computes the distance of the given object to the edge of this circle.
	\todo Implement distanceToEdge(CRay/CLineSegment/CLine).
	\return The distance of the given point to the edge of this circle. If the point is contained on this circle,
			the value 0 is returned.
	\see distanceToDisc(), closestPointToEdge(), closestPointToDisc(). */
	virtual float distanceToEdge(const CPoint2D &point) const;
//	virtual float distanceToEdge(const CRay2D &ray, float *d, CVec2D *closestPoint) const;
//	virtual float distanceToEdge(const CLineSegment2D &lineSegment, float *d, CVec2D *closestPoint) const;
//	virtual float distanceToEdge(const CLine2D &line, float *d, CVec2D *closestPoint) const;


	/** 
	\brief  Tests this disc for an intersection against the given object.
	\see intersects(). */
	virtual bool intersects(const CLine2D &line) const;
	virtual bool intersects(const CLineSegment2D &lineSegment) const;
 	virtual bool intersects(const CRay2D &ray) const;
	virtual bool intersects(const CPoint2D &p) const;
	virtual bool intersects(const CCircle2D &c) const;
	virtual bool intersects(const CAABBox2D &rhs) const;
	   /**
      \brief caluclate the intersection with straight line
      \param line considered line
      \param [out] ICnt number of intersections
      \param [out] I1 pointer to the 1st solution variable
      \param [out] I2 pointer to the 2nd solution variable
      \return true if there is an intersection
     */
    virtual bool intersection( const CLine2D & line, int *ICnt=NULL,CPoint2D * I1=NULL, CPoint2D * I2=NULL ) const;

    /**
      \brief calculate the intersection with ray line
      \param ray considered ray
      \param [out] ICnt number of intersections
      \param [out] I1 pointer to the 1st solution variable
      \param [out] I2 pointer to the 2nd solution variable
      \return true if there is an intersection
     */
    virtual bool intersection( const CRay2D & ray,int *ICnt=NULL,CPoint2D * I1=NULL, CPoint2D * I2=NULL ) const;

    /**
      \brief calculate the intersection with segment line
      \param segment considerd segment line
      \param [out] ICnt number of intersections
      \param [out] I1 pointer to the 1st solution variable
      \param [out] I2 pointer to the 2nd solution variable
      \return true if there is an intersection
     */
    virtual bool intersection( const CLineSegment2D & segment,int *ICnt=NULL,CPoint2D * I1=NULL, CPoint2D * I2=NULL ) const;

    /**
      \brief calculate the intersection with another circle
      \param circle considerd circle
      \param [out] ICnt number of intersections
      \param [out] I1 pointer to the 1st solution variable
      \param [out] I2 pointer to the 2nd solution variable
      \return true if there is an intersection
     */
    virtual bool intersection( const CCircle2D & circle,int *ICnt=NULL,CPoint2D * I1=NULL, CPoint2D * I2=NULL ) const;

	/** This function returns true if the given object lies inside this Circle, and false otherwise.
	\note The comparison is performed using less-or-equal, so the faces of this CAABBox count as being inside, but
		due to float inaccuracies, this cannot generally be relied upon.
	\see distance(), intersects(), closestPoint(). */
	virtual bool contains(const CVec2D &point) const;
	virtual bool contains(const CPoint2D &point) const;

    /** 
	\brief  Returns a human-readable representation of this circle. Most useful for debugging purposes.
	 The returned string specifies the center position, normal direction and the radius of this circle. */
	std::string toString() const;
	/**
	\return the lenght of the arc
	\param angle in radians
	\note  	ArcLen= RC
	where:
	C  is the central angle of the arc in radians.
	R  is the radius of the arc 
	*/
	SMF_INLINE virtual float arcLenght(float angle)const{ return r*angle;   };

#ifdef MATH_QT_INTEROP
	operator QString() const { return toString(); }
	QString toString() const { return QString::fromStdString(toString()); }
#endif
};

//CCircle2D operator *(const CMat2D &transform, const CCircle2D &circle);

#ifdef MATH_QT_INTEROP
Q_DECLARE_METATYPE(CCircle2D)
Q_DECLARE_METATYPE(CCircle2D*)
#endif

std::ostream &operator <<(std::ostream &o, const CCircle2D &circle);


} //end GEO
}  //end SMF

#endif // __SMF_CIRCLE_2D_
