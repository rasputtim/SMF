
#include <io.h>
#include <string>
#include <vector>
#include <queue>
#include <list>
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
//#include <values.h>
#include "SMF.h"

using namespace std;
using std::set_terminate;
using std::set_unexpected;
using std::set_new_handler;

/* CONMAT.C() - MyEllipse tranformation and intersection functions */
/* Written by Kenneth J. Hill, June, 24, 1994  */



#ifndef	M_PI_2
#define M_PI_2	1.57079632679489661923
#endif


/* Type definitions */
using namespace SMF::MATH;
	typedef SMF::GEO::CEllipse2D MyEllipse;
	typedef SMF::GEO::CConic2D Conic;
	typedef SMF::GEO::CPoint2D Point;
	typedef SMF::MATH::CVec2D Vec2;
	typedef SMF::GEO::CCircle2D Circle;
	typedef SMF::GEO::CRay2D Ray;
	typedef SMF::GEO::CLineSegment2D Segment;
	//typedef SMF::GEO::CLine2D Line;



/* transformation matrix type */
typedef struct TMatTag
   {
   float a,b,c,d;		 /* tranformation coefficients */
   float m,n;			 /* translation coefficients   */
   } TMat;

/* prototypes */

/* Functions with names beginning with a O:
 *
 * 1. Ignore MyEllipse center coordinates.
 *
 * 2. Ignore any translation components in tranformation matrices.
 *
 * 3. Assume that conic coeficients were generated by "O-name" functions.
 *
 * This keeps the computations relatively simple. The MyEllipse centers
 * can then be transformed separately as points.
 */

/* OTransformConic - Transform conic coefficients about the origin */
void OTransformConic(Conic *ConicP,TMat *TMatP);

/* OGenMyEllipseCoefs - Generate conic coefficients of an MyEllipse */
void OGenMyEllipseCoefs(MyEllipse *MyEllipseP,Conic *ConicP);

/* OGenMyEllipseGeom - Generates MyEllipse geometry from conic coefficients */
void OGenMyEllipseGeom(Conic *ConicP,MyEllipse *MyEllipseP);

/* TransformPoint - Transform a point using a tranformation matrix */
void TransformPoint(Point *PointP,TMat *TMatP);

/* TransformMyEllipse - Transform an MyEllipse using a tranformation matrix */
void TransformMyEllipse(MyEllipse *MyEllipseP,TMat *TMatP);



/* Identity matrix */
static const TMat IdentMat={1.0,0.0,0.0,1.0,0.0,0.0};

/* Transformation matrix routines */

/* Translate a matrix by m,n */
void TranslateMat(TMat *Mat,float m,float n)
   {
   Mat->m += m;
   Mat->n += n;
   }

/* Rotate a matrix by Phi */
void RotateMat(TMat *Mat,float Phi)
   {
   float SinPhi=sin(Phi);
   float CosPhi=cos(Phi);
   TMat temp=*Mat;		/* temporary copy of Mat */

   /* These are just the matrix operations written out long hand */
   Mat->a = temp.a*CosPhi - temp.b*SinPhi;
   Mat->b = temp.b*CosPhi + temp.a*SinPhi;
   Mat->c = temp.c*CosPhi - temp.d*SinPhi;
   Mat->d = temp.d*CosPhi + temp.c*SinPhi;
   Mat->m = temp.m*CosPhi - temp.n*SinPhi;
   Mat->n = temp.n*CosPhi + temp.m*SinPhi;
   }

/* Scale a matrix by sx, sy */
void ScaleMat(TMat *Mat,float sx,float sy)
   {
   Mat->a *= sx;
   Mat->b *= sy;
   Mat->c *= sx;
   Mat->d *= sy;
   Mat->m *= sx;
   Mat->n *= sy;
   }

/* TransformPoint - Transform a point using a tranformation matrix */
void TransformPoint(Point *PointP,TMat *TMatP)
   {
   Point TempPoint;

   TempPoint.x_ = PointP->x_*TMatP->a + PointP->y_*TMatP->c + TMatP->m;
   TempPoint.y_ = PointP->x_*TMatP->b + PointP->y_*TMatP->d + TMatP->n;
   *PointP=TempPoint;
   }

/* Conic routines */

/* near zero test */
#define EPSILON 1e-9
#define IsZero(x) (x > -EPSILON && x < EPSILON)

/* GenMyEllipseCoefs - Generate conic coefficients of an MyEllipse */
static void GenMyEllipseCoefs(MyEllipse *elip,Conic *M)
   {
   float sqr_r1,sqr_r2;
   float sint,cost,sin2t,sqr_sint,sqr_cost;
   float cenx,ceny,sqr_cenx,sqr_ceny,invsqr_r1,invsqr_r2;

   /* common coeficients */
   sqr_r1 = elip->a();
   sqr_r2 = elip->b();
   sqr_r1 *= sqr_r1;
   sqr_r2 *= sqr_r2;
   sint = sinf(elip->Phi);
   cost = cosf(elip->Phi);
   sin2t = 2.0*sint*cost;
   sqr_sint = sint*sint;
   sqr_cost = cost*cost;
   cenx = elip->center.x_;
   sqr_cenx = cenx*cenx;
   ceny = elip->center.y_;
   sqr_ceny = ceny*ceny;
   invsqr_r1 = 1.0/sqr_r1;
   invsqr_r2 = 1.0/sqr_r2;
   float A,B,C,D,E,F;
   /* Compute the coefficients. These formulae are the transformations
      on the unit circle written out long hand */
   A = sqr_cost/sqr_r1 + sqr_sint/sqr_r2;
   B = (sqr_r2-sqr_r1)*sin2t/(2.0*sqr_r1*sqr_r2);
   C = sqr_cost/sqr_r2 + sqr_sint/sqr_r1;
   D = -ceny*B-cenx*A;
   E = -cenx*B-ceny*C;
   F = -1.0 + (sqr_cenx + sqr_ceny)*(invsqr_r1 + invsqr_r2)/2.0 +
      (sqr_cost - sqr_sint)*(sqr_cenx - sqr_ceny)*(invsqr_r1 - invsqr_r2)/2.0 +
      cenx*ceny*(invsqr_r1 - invsqr_r2)*sin2t;
   M->setFromGen(A,B,C,D,E,F);
   }

/* Compute the transformation which turns an MyEllipse into a circle */
void Elp2Cir(MyEllipse *Elp,TMat *CirMat)
   {
   /* Start with identity matrix */
   *CirMat = IdentMat;
   /* Translate to origin */
   TranslateMat(CirMat,-Elp->center.x_,-Elp->center.y_);
   /* Rotate into standard position */
   RotateMat(CirMat,-Elp->Phi);
   /* Scale into a circle. */
   ScaleMat(CirMat,1.0/Elp->a(),1.0/Elp->b());
   }

/* Compute the inverse of the transformation
   which turns an MyEllipse into a circle */
void InvElp2Cir(MyEllipse *Elp,TMat *InvMat)
   {
   /* Start with identity matrix */
   *InvMat = IdentMat;
   /* Scale back into an MyEllipse. */
   ScaleMat(InvMat,Elp->a(),Elp->b());
   /* Rotate */
   RotateMat(InvMat,Elp->Phi);
   /* Translate from origin */
   TranslateMat(InvMat,Elp->center.x_,Elp->center.y_);
   }

/* OTransformConic - Transform conic coefficients about the origin	 */
/* This routine ignores the translation components of *TMatP and
   assumes the conic is "centered" at the origin (i.e. D,E=0, F=-1)	 */
/* The computations are just the matrix operations written out long hand */
/* This code assumes that the transformation is not degenerate		 */
void OTransformConic(Conic *ConicP,TMat *TMatP)
   {
   float A,B,C,D,E,F,Denom;

   /* common denominator for transformed cooefficients */
   Denom = TMatP->a*TMatP->d - TMatP->b*TMatP->c;
   Denom *= Denom;

   A = (ConicP->C()*TMatP->b*TMatP->b - 2.0*ConicP->B()*TMatP->b*TMatP->d +
      ConicP->A()*TMatP->d*TMatP->d)/Denom;

   B = (-ConicP->C()*TMatP->a*TMatP->b + ConicP->B()*TMatP->b*TMatP->c +
      ConicP->B()*TMatP->a*TMatP->d - ConicP->A()*TMatP->c*TMatP->d)/Denom;

   C = (ConicP->C()*TMatP->a*TMatP->a - 2.0*ConicP->B()*TMatP->a*TMatP->c +
      ConicP->A()*TMatP->c*TMatP->c)/Denom;
   D = ConicP->D();
   E = ConicP->E();
   F = ConicP->F();
   ConicP->setFromGen(A,B,C,D,E,F);
   }

/* OGenMyEllipseCoefs - Generate conic coefficients of an MyEllipse */
/* The MyEllipse is assumed to be centered at the origin. */
void OGenMyEllipseCoefs(MyEllipse *MyEllipseP,Conic *ConicP)
   {
   float SinPhi = sin(MyEllipseP->Phi); /* sine of MyEllipse rotation   */
   float CosPhi = cos(MyEllipseP->Phi); /* cosine of MyEllipse rotation */
   float SqSinPhi = SinPhi*SinPhi;    /* square of sin(phi)	     */
   float SqCosPhi = CosPhi*CosPhi;    /* square of cos(phi)	     */
   float SqMaxRad = MyEllipseP->a()*MyEllipseP->a();
   float SqMinRad = MyEllipseP->b()*MyEllipseP->b();
   float A,B,C,D,E,F;
   /* compute coefficients for the MyEllipse in standard position */
   A = SqCosPhi/SqMaxRad + SqSinPhi/SqMinRad;
   B = (1.0/SqMaxRad - 1.0/SqMinRad)*SinPhi*CosPhi;
   C = SqCosPhi/SqMinRad + SqSinPhi/SqMaxRad;
   D = E = 0.0;
   F = -1.0;
   ConicP->setFromGen(A,B,C,D,E,F);
   }

/* OGenMyEllipseGeom - Generates MyEllipse geometry from conic coefficients */
/* This routine assumes the conic coefficients D=E=0, F=-1 */
void OGenMyEllipseGeom(Conic *ConicP,MyEllipse *MyEllipseP)
   {
   float Numer,Denom,Temp;
   TMat DiagTransform;		 /* transform diagonalization */
   Conic ConicT = *ConicP;	 /* temporary copy of conic coefficients */
   float SinPhi,CosPhi;

   /* compute new MyEllipse rotation */
   Numer = ConicT.B() + ConicT.B();
   Denom = ConicT.A() - ConicT.C();
   /* Phi = 1/2 atan(Numer/Denom) = 1/2 (pi/2 - atan(Denom/Numer)
      We use the form that keeps the argument to atan between -1 and 1 */

   float Phi = 0.5*(fabs(Numer) < fabs(Denom)?
      atan(Numer/Denom) :  CMath::HALF_PI-atan(Denom/Numer));

   /* diagonalize the conic */
   SinPhi = sin(MyEllipseP->Phi);
   CosPhi = cos(MyEllipseP->Phi);
   DiagTransform.a = CosPhi;	 /* rotate by -Phi */
   DiagTransform.b = -SinPhi;
   DiagTransform.c = SinPhi;
   DiagTransform.d = CosPhi;
   DiagTransform.m = DiagTransform.n = 0.0;
   OTransformConic(&ConicT,&DiagTransform);

   /* compute new radii from diagonalized coefficients */
   float NewMaxRadio = 1.0/sqrt(ConicT.A());
   float NewMinRadio = 1.0/sqrt(ConicT.C());

   /* be sure a() >= b() */
   if (NewMaxRadio < NewMinRadio)
      {
      Temp = MyEllipseP->a();	 /* exchange the radii */
      NewMaxRadio = NewMinRadio;
      NewMinRadio = Temp;
      Phi += CMath::HALF_PI;	 /* adjust the rotation */
      }
   MyEllipseP->Set(Point(0,0),NewMaxRadio,NewMaxRadio,Phi);
   }

/* TransformMyEllipse - Transform an MyEllipse using a tranformation matrix */
void TransformMyEllipse(MyEllipse *MyEllipseP,TMat *TMatP)
   {
   Conic MyEllipseCoefs;

   /* generate the MyEllipse coefficients (using center=origin) */
   OGenMyEllipseCoefs(MyEllipseP,&MyEllipseCoefs);

   /* transform the coefficients */
   OTransformConic(&MyEllipseCoefs,TMatP);

   /* turn the transformed coefficients back into geometry */
   OGenMyEllipseGeom(&MyEllipseCoefs,MyEllipseP);

   /* translate the center */
   TransformPoint(&MyEllipseP->center,TMatP);
   }

/* MultMat3 - Multiply two 3x3 matrices */
void MultMat3(float *Mat1,float *Mat2, float *Result)
   {
   int i,j;

   for (i = 0;i < 3;i++)
      for (j = 0;j < 3;j++)
	 Result[i*3+j] = Mat1[i*3+0]*Mat2[0*3+j] +
	    Mat1[i*3+1]*Mat2[1*3+j] +
	    Mat1[i*3+2]*Mat2[2*3+j];
   }

/* Transform a conic by a tranformation matrix */
void TransformConic(Conic *ConicP,TMat *TMatP)
   {
   float InvMat[3][3],ConMat[3][3],TranInvMat[3][3];
   float Result1[3][3],Result2[3][3];
   float D;
   int i,j;

   /* Compute M' = Inv(TMat).M.Transpose(Inv(TMat))

   /* compute the transformation using matrix muliplication */
   ConMat[0][0] = ConicP->A();
   ConMat[0][1] = ConMat[1][0] = ConicP->B();
   ConMat[1][1] = ConicP->C();
   ConMat[0][2] = ConMat[2][0] = ConicP->D();
   ConMat[1][2] = ConMat[2][1] = ConicP->E();
   ConMat[2][2] = ConicP->F();

   /* inverse transformation */
   D = TMatP->a*TMatP->d - TMatP->b*TMatP->c;
   InvMat[0][0] = TMatP->d/D;
   InvMat[0][1] = -TMatP->b/D;
   InvMat[0][2] = 0.0;
   InvMat[1][0] = -TMatP->c/D;
   InvMat[1][1] = TMatP->a/D;
   InvMat[1][2] = 0.0;
   InvMat[2][0] = (TMatP->c*TMatP->n - TMatP->d*TMatP->m)/D;
   InvMat[2][1] = (TMatP->b*TMatP->m - TMatP->a*TMatP->n)/D;
   InvMat[2][2] = 1.0;

   /* compute transpose */
   for (i = 0;i < 3;i++)
      for (j = 0;j < 3;j++)
	 TranInvMat[j][i] = InvMat[i][j];

   /* multiply the matrices */
   MultMat3((float *)InvMat,(float *)ConMat,(float *)Result1);
   MultMat3((float *)Result1,(float *)TranInvMat,(float *)Result2);
   float A,B,C,D_,E,F;
   A = Result2[0][0];	       /* return to conic form */
   B = Result2[0][1];
   C = Result2[1][1];
   D_ = Result2[0][2];
   E = Result2[1][2];
   F = Result2[2][2];
   ConicP->setFromGen(A,B,C,D_,E,F);
   }

/* Compute the intersection of a circle and a line */
/* See Graphic Gems Volume 1, page 5 for a description of this algorithm */
int IntCirLine(Point *IntPts,Circle *Cir,Segment *Ln)
   {
   Point G,V;
   float a,b,c,d,t,sqrt_d;

   G.x_ = Ln->point1_.x_ - Cir->center.x_;     	/* G = Ln->point1_ - Cir->center */
   G.y_ = Ln->point1_.y_ - Cir->center.y_;
   V.x_ = Ln->point2_.x_ - Ln->point1_.x_;           /* V = Ln->point2_ - Ln->point1_ */
   V.y_ = Ln->point2_.y_ - Ln->point1_.y_;
   a = V.x_*V.x_ + V.y_*V.y_;		/* a = V.V */
   b = V.x_*G.x_ + V.y_*G.y_;b += b; 	/* b = 2(V.G) */
   c = (G.x_*G.x_ + G.y_*G.y_) -    	/* c = G.G + Circle->Radius^2 */
      Cir->r*Cir->r;
   d = b*b - 4.0*a*c;			/* discriminant */

   if (d <= 0.0)
      return 0;				/* no intersections */

   sqrt_d = sqrt(d);
   t = (-b + sqrt_d)/(a + a);           /* t = (-b +/- sqrt(d))/2a */
   IntPts[0].x_ = Ln->point1_.x_ + t*V.x_;      /* Pt = Ln->point1_ + t V */
   IntPts[0].y_ = Ln->point1_.y_ + t*V.y_;
   t = (-b - sqrt_d)/(a + a);
   IntPts[1].x_ = Ln->point1_.x_ + t*V.x_;
   IntPts[1].y_ = Ln->point1_.y_ + t*V.y_;
   return 2;
   }

/* compute all intersections of two MyEllipses */
/* E1 and E2 are the two MyEllipses */
/* IntPts points to an array of twelve points
    (some duplicates may be returned) */
/* The number of intersections found is returned */
/* Both MyEllipses are assumed to have non-zero radii */
int Int2Elip(Point *IntPts,MyEllipse *E1,MyEllipse *E2)
   {
   TMat ElpCirMat1,ElpCirMat2,InvMat,TempMat;
   Conic Conic1,Conic2,Conic3,TempConic;
   float Roots[3],qRoots[2];
   static Circle TestCir(Point(0.0,0.0),1.0);
   Segment TestLine[2];
   Point TestPoint;
   float PolyCoef[4];		/* coefficients of the polynomial */
   float D;			/* discriminant: B^2 - AC */
   float Phi;			/* MyEllipse rotation */
   float m,n;			/* MyEllipse translation */
   float Scl;			/* scaling factor */
   int NumRoots,NumLines;
   int CircleInts;		/* intersections between line and circle */
   int IntCount = 0;		/* number of intersections found */
   int i,j,k;

   /* compute the transformations which turn E1 and E2 into circles */
   Elp2Cir(E1,&ElpCirMat1);
   Elp2Cir(E2,&ElpCirMat2);

   /* compute the inverse transformation of ElpCirMat1 */
   InvElp2Cir(E1,&InvMat);

   /* Compute the characteristic matrices */
   GenMyEllipseCoefs(E1,&Conic1);
   GenMyEllipseCoefs(E2,&Conic2);

   /* Find x such that Det(Conic1 + x Conic2) = 0 */
   PolyCoef[0] = -Conic1.C()*Conic1.D()*Conic1.D() + 2.0*Conic1.B()*Conic1.D()*Conic1.E() -
      Conic1.A()*Conic1.E()*Conic1.E() - Conic1.B()*Conic1.B()*Conic1.F() +
      Conic1.A()*Conic1.C()*Conic1.F();
   PolyCoef[1] = -(Conic2.C()*Conic1.D()*Conic1.D()) -
      2.0*Conic1.C()*Conic1.D()*Conic2.D() + 2.0*Conic2.B()*Conic1.D()*Conic1.E() +
      2.0*Conic1.B()*Conic2.D()*Conic1.E() - Conic2.A()*Conic1.E()*Conic1.E() +
      2.0*Conic1.B()*Conic1.D()*Conic2.E() - 2.0*Conic1.A()*Conic1.E()*Conic2.E() -
      2.0*Conic1.B()*Conic2.B()*Conic1.F() + Conic2.A()*Conic1.C()*Conic1.F() +
      Conic1.A()*Conic2.C()*Conic1.F() - Conic1.B()*Conic1.B()*Conic2.F() +
      Conic1.A()*Conic1.C()*Conic2.F();
   PolyCoef[2] = -2.0*Conic2.C()*Conic1.D()*Conic2.D() - Conic1.C()*Conic2.D()*Conic2.D() +
      2.0*Conic2.B()*Conic2.D()*Conic1.E() + 2.0*Conic2.B()*Conic1.D()*Conic2.E() +
      2.0*Conic1.B()*Conic2.D()*Conic2.E() - 2.0*Conic2.A()*Conic1.E()*Conic2.E() -
      Conic1.A()*Conic2.E()*Conic2.E() - Conic2.B()*Conic2.B()*Conic1.F() +
      Conic2.A()*Conic2.C()*Conic1.F() - 2.0*Conic1.B()*Conic2.B()*Conic2.F() +
      Conic2.A()*Conic1.C()*Conic2.F() + Conic1.A()*Conic2.C()*Conic2.F();
   PolyCoef[3] = -Conic2.C()*Conic2.D()*Conic2.D() + 2.0*Conic2.B()*Conic2.D()*Conic2.E() -
      Conic2.A()*Conic2.E()*Conic2.E() - Conic2.B()*Conic2.B()*Conic2.F() +
      Conic2.A()*Conic2.C()*Conic2.F();
   NumRoots = SMF::MATH::CPolynomial::SolveCubic(PolyCoef,Roots);

   if (NumRoots == 0)
      return 0;

   /* we try all the roots, even though it's redundant, so that we
      avoid some pathological situations */
   for (i=0;i<NumRoots;i++)
      {
      NumLines = 0;
	  float A,B,C,D,E,F;
      /* Conic3 = Conic1 + mu Conic2 */
      A = Conic1.A() + Roots[i]*Conic2.A();
      B = Conic1.B() + Roots[i]*Conic2.B();
      C = Conic1.C() + Roots[i]*Conic2.C();
      D = Conic1.D() + Roots[i]*Conic2.D();
      E = Conic1.E() + Roots[i]*Conic2.E();
      F = Conic1.F() + Roots[i]*Conic2.F();
	  Conic3.setFromGen(A,B,C,D,E,F);
      D = Conic3.B()*Conic3.B() - Conic3.A()*Conic3.C();
      if (IsZero(Conic3.A()) && IsZero(Conic3.B()) && IsZero(Conic3.C()))
	 {
	 /* Case 1 - Single line */
	 NumLines = 1;
	 /* compute endpoints of the line, avoiding division by zero */
	 if (fabs(Conic3.D()) > fabs(Conic3.E()))
	    {
	    TestLine[0].point1_.y_ = 0.0;
	    TestLine[0].point1_.x_ = -Conic3.F()/(Conic3.D() + Conic3.D());
	    TestLine[0].point2_.y_ = 1.0;
	    TestLine[0].point2_.x_ = -(Conic3.E() + Conic3.E() + Conic3.F())/
	       (Conic3.D() + Conic3.D());
	    }
	 else
	    {
	    TestLine[0].point1_.x_ = 0.0;
	    TestLine[0].point1_.y_ = -Conic3.F()/(Conic3.E() + Conic3.E());
	    TestLine[0].point2_.x_ = 1.0;
	    TestLine[0].point2_.x_ = -(Conic3.D() + Conic3.D() + Conic3.F())/
	       (Conic3.E() + Conic3.E());
	    }
	 }
      else
	 {
	 /* use the espresion for Phi that takes atan of the
	    smallest argument */
	 Phi = (fabs(Conic3.B() + Conic3.B()) < fabs(Conic3.A()-Conic3.C())?
	    atan((Conic3.B() + Conic3.B())/(Conic3.A() - Conic3.C())) :
	    CMath::HALF_PI - atan((Conic3.A() - Conic3.C())/(Conic3.B() + Conic3.B())))/2.0;
	 if (IsZero(D))
	    {
	    /* Case 2 - Parallel lines */
	    TempConic = Conic3;
	    TempMat = IdentMat;
	    RotateMat(&TempMat,-Phi);
	    TransformConic(&TempConic,&TempMat);
	    if (IsZero(TempConic.C()))   /* vertical */
	       {
	       PolyCoef[0] = TempConic.F();
	       PolyCoef[1] = TempConic.D();
	       PolyCoef[2] = TempConic.A();
	       if ((NumLines=SMF::MATH::CPolynomial::SolveQuadratic(PolyCoef,qRoots))!=0)
		  {
		  TestLine[0].point1_.x_ = qRoots[0];
		  TestLine[0].point1_.y_ = -1.0;
		  TestLine[0].point2_.x_ = qRoots[0];
		  TestLine[0].point2_.y_ = 1.0;
		  if (NumLines==2)
		     {
		     TestLine[1].point1_.x_ = qRoots[1];
		     TestLine[1].point1_.y_ = -1.0;
		     TestLine[1].point2_.x_ = qRoots[1];
		     TestLine[1].point2_.y_ = 1.0;
		     }
		  }
	       }
	    else		    /* horizontal */
	       {
	       PolyCoef[0] = TempConic.F();
	       PolyCoef[1] = TempConic.E();
	       PolyCoef[2] = TempConic.C();
	       if ((NumLines=SMF::MATH::CPolynomial::SolveQuadratic(PolyCoef,qRoots))!=0)
		  {
		  TestLine[0].point1_.x_ = -1.0;
		  TestLine[0].point1_.y_ = qRoots[0];
		  TestLine[0].point2_.x_ = 1.0;
		  TestLine[0].point2_.y_ = qRoots[0];
		  if (NumLines==2)
		     {
		     TestLine[1].point1_.x_ = -1.0;
		     TestLine[1].point1_.y_ = qRoots[1];
		     TestLine[1].point2_.x_ = 1.0;
		     TestLine[1].point2_.y_ = qRoots[1];
		     }
		  }
	       }
	    TempMat = IdentMat;
	    RotateMat(&TempMat,Phi);
	    TransformPoint(&TestLine[0].point1_,&TempMat);
	    TransformPoint(&TestLine[0].point2_,&TempMat);
	    if (NumLines==2)
	       {
	       TransformPoint(&TestLine[1].point1_,&TempMat);
	       TransformPoint(&TestLine[1].point2_,&TempMat);
	       }
	    }
	 else
	    {
	    /* Case 3 - Crossing lines */
	    NumLines = 2;

	    /* translate the system so that the intersection of the lines
	       is at the origin */
	    TempConic = Conic3;
	    m = (Conic3.C()*Conic3.D() - Conic3.B()*Conic3.E())/D;
	    n = (Conic3.A()*Conic3.E() - Conic3.B()*Conic3.D())/D;
	    TempMat = IdentMat;
	    TranslateMat(&TempMat,-m,-n);
	    RotateMat(&TempMat,-Phi);
	    TransformConic(&TempConic,&TempMat);

	    /* Compute the line endpoints */
	    TestLine[0].point1_.x_ = sqrt(fabs(1.0/TempConic.A()));
	    TestLine[0].point1_.y_ = sqrt(fabs(1.0/TempConic.C()));
	    Scl = MAX(TestLine[0].point1_.x_,TestLine[0].point1_.y_);  /* adjust range */
	    TestLine[0].point1_.x_ /= Scl;
	    TestLine[0].point1_.y_ /= Scl;
	    TestLine[0].point2_.x_ = - TestLine[0].point1_.x_;
	    TestLine[0].point2_.y_ = - TestLine[0].point1_.y_;
	    TestLine[1].point1_.x_ = TestLine[0].point1_.x_;
	    TestLine[1].point1_.y_ = - TestLine[0].point1_.y_;
	    TestLine[1].point2_.x_ = - TestLine[1].point1_.x_;
	    TestLine[1].point2_.y_ = - TestLine[1].point1_.y_;

	    /* translate the lines back */
	    TempMat = IdentMat;
	    RotateMat(&TempMat,Phi);
	    TranslateMat(&TempMat,m,n);
	    TransformPoint(&TestLine[0].point1_,&TempMat);
	    TransformPoint(&TestLine[0].point2_,&TempMat);
	    TransformPoint(&TestLine[1].point1_,&TempMat);
	    TransformPoint(&TestLine[1].point2_,&TempMat);
	    }
	 }

      /* find the MyEllipse line intersections */
      for (j = 0;j < NumLines;j++)
	 {
	 /* transform the line endpts into the circle space of the MyEllipse */
	 TransformPoint(&TestLine[j].point1_,&ElpCirMat1);
	 TransformPoint(&TestLine[j].point2_,&ElpCirMat1);

	 /* compute the number of intersections of the transformed line
	    and test circle */
	 CircleInts = IntCirLine(&IntPts[IntCount],&TestCir,&TestLine[j]);
	 if (CircleInts>0)
	    {
	    /* transform the intersection points back into MyEllipse space */
	    for (k = 0;k < CircleInts;k++)
	       TransformPoint(&IntPts[IntCount+k],&InvMat);
	    /* update the number of intersections found */
	    IntCount += CircleInts;
	    }
	 }
      }
   /* validate the points */
   j = IntCount;
   IntCount = 0;
   for (i = 0;i < j;i++)
      {
      TestPoint = IntPts[i];
      TransformPoint(&TestPoint,&ElpCirMat2);
      if (TestPoint.x_ < 2.0 && TestPoint.y_ < 2.0 &&
	 IsZero(1.0 - sqrt(TestPoint.x_*TestPoint.x_ +
	 TestPoint.y_*TestPoint.y_)))
	 IntPts[IntCount++]=IntPts[i];
      }
   return IntCount;
   }

/* Test routines */

/* MyEllipse with center at (1,2), major radius 2, minor radius 1,
   and rotation 0. */
MyEllipse TestMyEllipse(Point(2.0,1.0),2.0,1.0,0.0);

/* Transform matrix for shear of 45 degrees from vertical */
TMat TestTransform={1.0,0.0,1.0,1.0,0.0,0.0};

/* Display an MyEllipse. This version lists the structure values. */
void DisplayMyEllipse(MyEllipse *MyEllipseP)
   {
   printf("\tCenter at (%6.3f,%6.3f)\n"
      "\tMajor radius: %6.3f\n"
      "\tMinor radius: %6.3f\n"
      "\tRotation: %6.3f degrees\n\n",
      MyEllipseP->center.x_,MyEllipseP->center.y_,
      MyEllipseP->a(),MyEllipseP->b(),
      180.0*MyEllipseP->Phi/CMath::PI);
   }


/* test MyEllipses for intersection */
MyEllipse Elp1(Point(5.0,4.0),1.0,0.5,CMath::PI/3.0);
MyEllipse Elp2(Point(4.0,3.0),2.0,1.0,0.0);
MyEllipse Elp3(Point(1.0,1.0),2.0,1.0,M_PI_2);
MyEllipse Elp4(Point(1.0,1.0),2.0,0.5,0.0);
MyEllipse Sal1(CPoint2D(0.0,1.0),4.0,2.0,0.0);
MyEllipse Sal2(CPoint2D(0.0,2.0),CMath::Sqrt(2),CMath::Sqrt(12),0.0);





//This is for the normal PC
//The programm entry point
int main(int argc,char *argv[])
{

		//==============================
	SMF::Debug::setDebugAll();
	SMF::Debug::setFilename("debug_math.txt");
	SMF::Debug::setDebugMethod(SMF::Debug::File);


	SMF::MATH::CSIMD::initHeap();
  Point IntPts[12];
   int IntCount;
   int i;
   /* find MyEllipse intersections */
   printf("Intersections of MyEllipses 1 & 2:\n\n");
   IntCount=Int2Elip(IntPts,&Sal1,&Sal2);
   for (i = 0;i < IntCount;i++)
      printf("   %f, %f\n",IntPts[i].x_,IntPts[i].y_);

   /* find MyEllipse intersections */
   printf("Intersections of MyEllipses 1 & 2:\n\n");
   IntCount=Int2Elip(IntPts,&Elp1,&Elp2);
   for (i = 0;i < IntCount;i++)
      printf("   %f, %f\n",IntPts[i].x_,IntPts[i].y_);
   printf("Intersections of MyEllipses 3 & 4:\n");
   IntCount=Int2Elip(IntPts,&Elp3,&Elp4);
   for (i = 0;i < IntCount;i++)
      printf("   %f, %f\n",IntPts[i].x_,IntPts[i].y_);

   /* transform MyEllipses */
   printf("\n\nBefore transformation:\n");
   DisplayMyEllipse(&TestMyEllipse);

   TransformMyEllipse(&TestMyEllipse,&TestTransform);

   printf("After transformation:\n");
   DisplayMyEllipse(&TestMyEllipse);


	SMF::MATH::CSIMD::shutdown();

    return 0;

}



